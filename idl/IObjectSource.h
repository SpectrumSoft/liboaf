/**
 * @file
 * @brief Пакет интерфейсов подсистемы коллекций и источников объектов
 * @author Sergey N. Yatskevich <syatskevich@gmail.com>
 * @copyright SpectrumSoft. All rights reserved. This file is part of liboaf,
 *            distributed under the GNU GPL v2 with a Linking Exception. For
 *            full terms see the included COPYING file.
 */
#ifndef __IOBJECT_SOURCE_H
#define __IOBJECT_SOURCE_H

#include <QtCore>

#include <idl/IInterface.h>
#include <idl/IUnknown.h>
#include <idl/INotifySource.h>
#include <idl/IPropertyBag.h>

namespace OAF
{
	/**
	 * @brief Коллекция объектов
	 *
	 * Выделение из OAF::IObjectSource отдельного интерфейса OAF::IObjectCollection связано с тем,
	 * что не всем реализациям нужна возможность добавлять или удалять объекты. В частности моникеру
	 * '!' нужна только возможность запросить объект, соответствующий заданным параметрам
	 */
	struct IObjectCollection : virtual public OAF::IInterface
	{
		/**
		 * @brief Список идентификаторов всех объектов коллекции
		 *
		 * @param[out] _out   идентификаторы отобранных объектов. Если заданный список не пуст, то
		 *                    вновь загружаемые идентификаторы должны добавиться к уже имеющемуся
		 *                    списку
		 * @param[in] _params параметры, которым должны соответствовать отобранные объекты. В данный
		 *                    набор параметров может входить в том числе и порядок сортировки
		 *                    объектов. Конкретный способ задания параметров определяется реализацией
		 *                    данного интерфейса
		 * @param[in] _loaded количество ранее загруженных идентификаторов. Данный параметр
		 *                    предназначен для реализации инкрементальной обработки объектов
		 *                    коллекции
		 *
		 * @return Количество дополнительно полученных идентификаторов
		 */
		virtual std::size_t enumObjects (QStringList& _out, const QString& _params = QString (), std::size_t _loaded = 0) = 0;

		/**
		 * @brief Получить объект с заданным идентификатором
		 *
		 * @param[in] _oid идентификатор объекта. Конкретный способ задания идентификатора
		 *                 определяется реализацией данного интерфейса
		 *
		 * @return Ссылка на объект
		 *
		 * Поскольку конкретный вид идентификатора определяется реализацией, то он может быть
		 * любой формы. Главное ограничение данного метода то, что возвращается только один
		 * объект
		 */
		virtual OAF::URef<OAF::IUnknown> getObject (const QString& _oid) = 0;
	};

	/**
	 * @brief Источник объектов
	 *
	 * Данный интерфейс расширяет интерфейс OAF::IObjectCollection возможностями по управлению
	 * объектами коллекции
	 */
	struct IObjectSource : virtual public OAF::IObjectCollection
	{
		/**
		 * @brief Удаление объектов из коллекции
		 *
		 * @param[in] _params параметры, которым должны соответствовать удаляемые объекты. Конкретный
		 *                    способ задания параметров определяется реализацией данного интерфейса
		 * @param[in] _origin инициатор удаления объектов
		 *
		 * @return количество удалённых из коллекции объектов
		 */
		virtual std::size_t removeObjects (const QString& _params, OAF::INotifyListener* _origin = NULL) = 0;

		/**
		 * @brief Добавить объект в коллекцию
		 *
		 * @param[in] _oid    идентификатор добавляемого объекта
		 * @param[in] _object объект для добавления
		 * @param[in] _origin инициатор добавления объекта
		 *
		 * Данный метод может вернуть не тот же объект, что передан ему в качестве параметра.
		 * Это определяется реализацией. В общем случае в дальнейшем следует использовать
		 * возвращённый объект. Способ идентификации объекта, а так же поведение коллекции при
		 * добавлении дубликатов, определяется реализацией данного интерфейса
		 */
		virtual OAF::URef<OAF::IUnknown> appendObject (const QString& _oid, OAF::IUnknown* _object, OAF::INotifyListener* _origin = NULL) = 0;
	};

	/**
	 * @brief Уведомления, генерируемые источниками/коллекциями объектов
	 *
	 * Используется в реализациях, которые предполагают рассылку уведомлений о добавлении/удалении
	 * объектов. Такие объекты должны также поддерживать интерфейс OAF::INotifySource.
	 *
	 * За изменением атрибутов объектов следует следить с помощью IPropertyEvent.
	 */
	struct IObjectNotify : virtual public OAF::IInterface
	{
		/**
		 * @brief Исключение, прерывающее добавление/удаление объекта
		 *
		 * Обработчик уведомлений на этапе OAF::IObjectNotify::BEFORE может выбросить это исключение
		 * для того, чтобы прервать операцию добавления/удаления объекта.
		 *
		 * @attention
		 * IDL-OBS-001. При возникновении такого исключения добавление/удаление объекта должно
		 * быть прервано и всем обработчикам уведомлений должно быть разослано сообщение
		 * OAF::IObjectNotify::CANCELLED для того, чтобы они могли соответствующим образом среагировать
		 * на отказ в добавлении/удалении объекта.
		 */
		struct Cancel
		{}
		;

		/**
		 * @brief Этапы создание/удаления объекта
		 *
		 * При удалении группы объектов сначала для всех должны быть разосланы уведомления
		 * OAF::IObjectNotify::BEFORE, а затем OAF::IObjectNotify::AFTER. В случае возникновения
		 * исключения OAF::IObjectNotify::Cancel ни один из объектов не должен быть удалён. При
		 * отмене удаления уведомление OAF::IObjectNotify::CANCELLED должно рассылаться только
		 * для тех объектов, для которых ранее было разослано уведомление OAF::IObjectNotify::BEFORE.
		 */
		enum When
		{
			BEFORE,   //!< Перед добавлением/удалением объекта
			AFTER,    //!< После добавления/удаления объекта
			CANCELLED //!< При отмене добавления/удаления объекта
		};

		/**
		 * @brief Действия, выполняемые над объектами
		 */
		enum Action
		{
			APPEND, //!< Добавление объекта
			REMOVE  //!< Удаление объекта
		};

		/**
		 * @brief Этап выполнения действия
		 */
		const When when;

		/**
		 * @brief Выполняемое над объектом действие
		 */
		const Action action;

		/**
		 * @brief Добавленный/удалённый объект
		 *
		 * При удалении объекта в фазе AFTER данный параметр может быть равен NULL, так как
		 * на этом этапе объект в коллекции может уже отсутствовать. При добавлении объекта
		 * аналогичная ситуация может быть в фазе BEFORE.
		 */
		OAF::IInterface* const object;

		/**
		 * @brief Конструктор уведомления
		 *
		 * После создания уведомления его атрибуты не могут быть модифицированы
		 */
		IObjectNotify (When _when, Action _action, OAF::IInterface* _object) :
			when (_when), action (_action), object (_object)
		{}
		;
	};
}

#endif /* _IOBJECT_SOURCE_H */
