/**
 * @file
 * @brief Базовый интерфейс
 * @author Sergey N. Yatskevich <syatskevich@gmail.com>
 * @copyright SpectrumSoft. All rights reserved. This file is part of liboaf,
 *            distributed under the GNU GPL v2 with a Linking Exception. For
 *            full terms see the included COPYING file.
 */
#ifndef __IINTERFACE_H
#define __IINTERFACE_H

//
// Снимает warning MSVS-компилятора о "inherits via dominance" - когда идет вызов метода
// базового класса без указания, из какого конкретно базового класса его вызывать.
//
// Возникает при виртуальном наследовании, когда одна и та же сигнатура метода доступна
// через несколько виртуальных базовых классах
//
#ifdef _MSC_VER
#pragma warning (disable: 4250)
#endif

#include <cstddef>

#include <QMetaType>
#include <QUuid>
#include <QSet>

/**
 * @name Декларации метатипов для QUuid и QSet<QUuid>
 *
 * Почему то QUuid не имеет своей декларации метатипа, что не позволяет его хранить
 * в QVariant. Данное объявление делает хранение QUuid внутри QVariant возможным.
 *
 * Размещаем это объявление здесь так как данный файл гарантировано включается в
 * любой исходник.
 */
/** @{*/
Q_DECLARE_METATYPE (QUuid)
Q_DECLARE_METATYPE (QSet<QUuid>)
/** @}*/

namespace OAF
{
	/**
	 * @brief Базовый интерфейс для всей иерархии интерфейсов
	 *
	 * @attention
	 * IDL-IFS-001. Интерфейс - это структура (класс только с открытыми членами), содержащая:
	 *    - определения типов;
	 *    - абстрактные методы;
	 *    - константы и константные атрибуты;
	 *    - функции и методы, упрощающие работу с интерфейсом со стороны клиентов, применимые ко
	 *      всем реализациям данного интерфейса.
	 *
	 * Два последних пункта, по возможности, следует выносить в библиотеки реализаций, если только они
	 * не являются частью протокола взаимодействия с интерфейсом или не нужны для определения других
	 * интерфейсов.
	 *
	 * @attention
	 * IDL-IFS-002. Интерфейсы должны быть определены так, чтобы для их использования не нужно было
	 * ничего, кроме файла, в котором они определёны.
	 *
	 * @attention
	 * IDL-IFS-003. Все требования, которым обязаны следовать реализация и клиент и которые не могут
	 * быть выражены в виде C++ кода, должны быть записаны явно в виде комментариев и пронумерованы в
	 * формате IDL-<код пакета>-<номер требования в пакете> для ссылок на это требование из других
	 * частей документации. Все такие требования должны быть помечены ключевым словом Doxygen
	 * @c attention для того, чтобы быть выделенными при генерации документации.
	 *
	 * С точки зрения C++ базовым свойством интерфейса является наличие виртуальной таблицы (в которой
	 * хранится описание типа для работы RTTI) и виртуального деструктора.
	 *
	 * @attention
	 * IDL-IFS-004. Наследование интерфейсов должно быть обязательно виртуальным и публичным, поскольку
	 * любой объект должен содержать ровно один интерфейс заданного типа вне зависимости от сложности
	 * иерархии наследования интерфейсов.
	 */
	struct IInterface
	{
		virtual ~IInterface ()
		{}
		;
	};

	/**
	 * @brief Преобразование между интерфейсами
	 *
	 * Это аналог queryInterface в Bonobo/COM
	 *
	 * @attention
	 * IDL-IFS-005. dynamic_cast для gcc2.95 при сложной системе множественного виртуального
	 * наследования классов начинает давать неправильные значения указателей, что приводит к падению
	 * программы, поэтому использование компилятора этой версии категорически запрещается.
	 */
	template<class _Interface1, class _Interface2>
	inline _Interface1*
	queryInterface (_Interface2* _i)
	{
		return dynamic_cast<_Interface1*> (_i);
	}

	/**
	 * @brief Преобразование между константными интерфейсами
	 *
	 * Это аналог queryInterface в Bonobo/COM
	 *
	 * @attention
	 * IDL-IFS-005. dynamic_cast для gcc2.95 при сложной системе множественного виртуального
	 * наследования классов начинает давать неправильные значения указателей, что приводит к падению
	 * программы, поэтому использование компилятора этой версии категорически запрещается.
	 */
	template<class _Interface1, class _Interface2>
	inline const _Interface1*
	queryInterface (const _Interface2* _i)
	{
		return dynamic_cast<const _Interface1*> (_i);
	}
}

#endif /* __IINTERFACE_H */
